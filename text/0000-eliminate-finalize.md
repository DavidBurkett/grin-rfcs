
- Title: Eliminate Finalize Step
- Authors: [David Burkett](mailto:davidburkett38@gmail.com)
- Start date: Aug 09, 2020
- RFC PR: Edit if merged: [mimblewimble/grin-rfcs#0000](https://github.com/mimblewimble/grin-rfcs/pull/0000) 
- Tracking issue: [Edit if merged with link to tracking github issue]

---

# Summary
[summary]: #summary

Use one-time addresses which include a pre-generated public excess and public nonce in order to eliminate the 3rd step in transaction building (finalize) [1].

# Motivation
[motivation]: #motivation

To simplify transaction building.

# Community-level explanation
[community-level-explanation]: #community-level-explanation

This feels like unnecessary red tape. See summary.

# Reference-level explanation
[reference-level-explanation]: #reference-level-explanation

## Address Generation

As of the introduction of slatepacks, we already have a standardized system for generating addresses [4]. To support eliminating the finalize step, we must extend these addresses to include a public excess and a public nonce. The new addresses are for one-time use only.

The address format will be `version | ed25519_key | public_excess | public_nonce` bech32 encoded using `grin` as the HRC and `1` as the version. They are easily distinguishable from the existing slatepack addresses due to their additional length (1 additional byte for version, 33 additional bytes for `public_excess` and 33 additional bytes for `public_nonce`).

Example: 

version: 1
ed25519 pubkey: 0x8fe91a51badcebca96d5c8f35daf4c0419ac5312b58fa6496c361420958f90ba
public excess: 0x03639592cc3d406a1773ead98b59aa0c54c10e6412edfcdf78c45faf6c810d90d4
public nonce: 0x0332e9abd666ab919b22613e7f6332f449c9adb46b323b0d069953faabf15cfd45
bech32 address: grin1qx87jxj3htwwhj5k6hy0xhd0fszpntznz26clfjfdsmpggy437gt5qmrjkfvc02qdgth86ke3dv65rz5cy8xgyhdln0h33zl4akgzrvs6spn96dt6en2hyvmyfsnulmrxt6ynjddk34nywcdq6v4874t79w063gugaa22

## Payment Proofs

### Building the proof

Define `diffie_secret` as the Diffie-Hellman secret, which can be computed by only the sender and the receiver:
`diffie_secret` = `Hash(sender.nonce * receiver.public_nonce)` = `Hash(sender.public_nonce * receiver.nonce)`

Calculate `proof_nonce` = `Hash(diffie_secret | receiver.public_excess | tx.amount)`.

The `total_nonce` for the transaction will then be `sender.nonce + receiver.nonce + proof_nonce`.

* `e = SHA256(M | sender.public_nonce + receiver.public_nonce + (proof_nonce * G) | sender.public_excess + receiver.public_excess)`
* The sender's partial signature will be `sender.partial_sig = sender.nonce + e * sender.excess`
* The receiver's partial signature will be `receiver.partial_sig = receiver.nonce + e * receiver.excess` 

The final aggregated kernel signature `(s, k*G)` can then be calculated as `(sender.partial_sig + receiver.partial_sig + proof_nonce, total_nonce * G)`

### Verifying the proof

The following 4 steps are necessary for the sender to prove payment to the receiver's address:

1. Provide the kernel and show that it was confirmed on-chain.
2. Prove knowledge of `sender.nonce`
3. Show that `sender.public_nonce + receiver.public_nonce + (proof_nonce * G)` = `total_nonce * G` (ie. the `k*G` in the kernel signature)
4. Provide the preimage to `proof_nonce` (`diffie_secret | receiver.public_excess | tx.amount`)

## Slate Format

A slate is now only needed for passing information from the sender to receiver. It must include the following data:

* `tx.amount`
* `tx.offset`
* `tx.kernel_features`
* `tx.fee`
* `tx.inputs`
* `receiver.change_output`
* `receiver.public_excess` & `receiver.public_nonce` (to prevent the need for grinding)
* `sender.public_excess`, `sender.public_nonce`, & `sender.partial_sig`
* `time_to_live` (optional)

TODO: Define JSON & binary formats
TODO: Mention QR codes

## Backward Compatibility

TODO: Decide how to handle versioning. In theory, this should be simple. If given an old slatepack address, use the old slate format. If given a new, one-time address, then the new slate format is supported.

## Invoices

To send an invoice to a payer, the recipient provides the payer with a newly generated one-time address, an amount, and any additional fields we decide to support (memo, refund address, expiration, etc). The payer, upon approving payment of the invoice, simply follows the standard 2-step send process described in this RFC. There's no need for a special workflow.

## Security

### Nonce Reuse

Nonces should be randomly generated by the receiving wallet, rather than derived from seed, since reuse of a nonce could lead to loss of funds. Receiving wallets should keep track of all one-time addresses (excesses & nonces) they generate in a list (`address_list`), along with an indicator for whether they have been used yet.

Upon receipt of a partial transaction (slate), the receiver should obtain a lock on `address_list` and then check whether the address has been used before. If it has not, it's safe to finalize the transaction, but before broadcasting, the address should be marked as used in the `address_list`, and then the lock can be safely released.

### Play Attacks

TODO: Describe play attacks, and finish this section.

Any inputs sent from a wallet to a one-time address should be considered as sent. They should not be cancelable, however, the sender should have the option to add additional inputs and/or increase the fee (equivalent of bitcoin's RBF).

Receiver should be unable to claim a problem with the transaction. If they do, it's trivial to show them the slate that was sent, and prove that it's a valid partial transaction containing everything necessary for the receiver to finalize.

# Drawbacks
[drawbacks]: #drawbacks

Addresses are significantly longer (170 characters).

Using one-time addresses increases the risk of "Play" attacks [2]. Recommendations for dealing with these have been discussed in the above "Play attacks" section.

# Rationale and alternatives
[rationale-and-alternatives]: #rationale-and-alternatives

An alternative approach to simplifying transaction building is to support non-interactive transactions [3].

# Unresolved questions
[unresolved-questions]: #unresolved-questions

* Can this be used to simplify sending to a multisig address?

# Future possibilities
[future-possibilities]: #future-possibilities

Eliminating finalize brings us one step closer to supporting receive-only wallets, and even hardware wallets. Offline wallets could pre-generate dozens, hundreds, or even thousands of address-nonce pairs, which can be given to a receive-only wallet which distributes them to potential senders, and collects & verifies any partial transactions provided to them. At any time in the future, those partial transactions can be provided to the offline wallet for signing, without needing to later contact the sender.

# Credits

Thanks to Kurt Coolman for coming up with the general design for payment proofs [5].

# References
[references]: #references

[1] https://forum.grin.mw/t/eliminating-finalize-step/7621
[2] https://forum.grin.mw/t/play-attacks-and-possible-mitigations/7527
[3] https://github.com/litecoin-project/lips/pull/13
[4] https://github.com/mimblewimble/grin-rfcs/blob/master/text/0015-slatepack.md#slatepackaddress
[5] https://forum.grin.mw/t/eliminating-finalize-step/7621/22